[
  {
    "id": "1",
    "title": "Personal Link Hub",
    "description": "A single-file, responsive portfolio to showcase your social links. Perfect for testing basic HTML/CSS generation.",
    "tags": [
      "Beginner",
      "HTML/CSS",
      "Static",
      "Single-File"
    ],
    "prompt": "**System Role**: You are an expert Frontend Agent specialized in semantic HTML and modern CSS.\n**Objective**: Create a \"Link Hub\" (Linktree clone) in a single `index.html` file.\n\n**Tool Usage Constraints**:\n1.  Use `run_command` to create a directory named `link-hub`.\n2.  Use `write_to_file` to create the `index.html` file inside it.\n\n**Implementation Details**:\n*   **Structure**: Use semantic tags (`<header>`, `<main>`, `<footer>`).\n*   **Styling**:\n    *   Use an internal `<style>` block.\n    *   **Theme**: \"Cyberpunk Lite\" - Dark background (`#0f0f0f`), neon purple accents (`#b026ff`), and white text.\n    *   **Layout**: Flexbox column, centered, max-width 480px.\n    *   **Buttons**: Full width, rounded-xl, glassmorphism effect (`backdrop-filter: blur(10px)`, `background: rgba(255,255,255,0.1)`).\n*   **Interactions**:\n    *   Add a simple JS script for a \"Share\" button that copies the current URL to the clipboard using the Clipboard API.\n\n**Verification**:\n*   After writing the file, the user should be able to open it directly in a browser without a build step.",
    "author": "Santhosh Sachin",
    "createdAt": "2025-12-09T10:00:00Z"
  },
  {
    "id": "2",
    "title": "Local Markdown Editor",
    "description": "A React-based markdown editor using Vite. Teaches the agent to scaffold projects and install dependencies.",
    "tags": [
      "Beginner",
      "React",
      "Vite",
      "Tailwind"
    ],
    "prompt": "**System Role**: You are a React Developer Agent.\n**Objective**: Scaffold and build a Local Markdown Editor.\n\n**Workflow & Tooling**:\n\n**Phase 1: Scaffolding**\n1.  **Command**: Use `run_command` to execute:\n    ```bash\n    npm create vite@latest markdown-editor -- --template react\n    cd markdown-editor\n    npm install\n    npm install react-markdown\n    npm install -D tailwindcss postcss autoprefixer\n    npx tailwindcss init -p\n    ```\n2.  **Configuration**: Use `write_to_file` to configure `tailwind.config.js` to scan `./src/**/*.{js,jsx,ts,tsx}`.\n3.  **Styles**: Overwrite `src/index.css` with Tailwind directives.\n\n**Phase 2: Implementation**\n1.  **Component**: Modify `src/App.jsx`.\n    *   **Layout**: Split screen (50% Textarea, 50% Preview).\n    *   **State**: Use `useState` for the markdown text.\n    *   **Persistence**: Use `useEffect` to save/load text from `localStorage`.\n    *   **Rendering**: Use `<ReactMarkdown>` component for the preview side.\n\n**Phase 3: Verification**\n1.  **Build**: Run `npm run build` via `run_command`.\n2.  **Check**: Ensure exit code is 0.",
    "author": "Santhosh Sachin",
    "createdAt": "2025-12-09T10:00:00Z"
  },
  {
    "id": "3",
    "title": "Random Quote Generator",
    "description": "A vanilla JS app that fetches data from an API. Focuses on error handling and DOM manipulation.",
    "tags": [
      "Beginner",
      "API",
      "JavaScript",
      "DOM"
    ],
    "prompt": "**System Role**: You are a JavaScript Specialist Agent.\n**Objective**: Build a robust \"Random Quote Generator\" that handles API failures gracefully.\n\n**Tools**: `run_command` (for directory creation), `write_to_file`.\n\n**Requirements**:\n1.  **Setup**: Create folder `quote-generator`.\n2.  **Files**: Create `index.html`, `style.css`, and `app.js`.\n3.  **Logic (`app.js`)**:\n    *   **API**: Fetch from `https://api.quotable.io/random`.\n    *   **Robustness**: You MUST use a `try/catch` block.\n    *   **Fallback**: Define a local array of 5 backup quotes to use if the fetch fails (network error).\n    *   **UI Update**: Dynamically update the DOM elements for Quote and Author.\n4.  **Styling**:\n    *   Use CSS Variables for colors.\n    *   Implement a \"New Quote\" button with a loading spinner state while fetching.\n\n**Verification**:\n*   The code must run without a bundler (standard ES6 modules or plain script tags).",
    "author": "Santhosh Sachin",
    "createdAt": "2025-12-09T10:00:00Z"
  },
  {
    "id": "4",
    "title": "Weather Dashboard",
    "description": "A multi-component React app with API integration. Requires structured component planning.",
    "tags": [
      "Medium",
      "React",
      "Axios",
      "Environment Variables"
    ],
    "prompt": "**System Role**: You are a Frontend Architect Agent.\n**Objective**: Build a modular Weather Dashboard using React and Axios.\n\n**Agentic Workflow**:\n\n**1. Project Setup**\n*   Use `run_command` to scaffold a Vite React project: `weather-dash`.\n*   Install dependencies: `npm install axios lucide-react` (for icons).\n\n**2. Architecture & File Structure**\n*   You must create the following structure using `write_to_file`:\n    *   `src/api/weather.js`: Encapsulate all API calls here. Do not make calls directly in components.\n    *   `src/components/SearchBar.jsx`: Controlled input with validation.\n    *   `src/components/CurrentWeather.jsx`: Display temp, humidity, wind.\n    *   `src/components/ForecastGrid.jsx`: Map over 5-day data.\n    *   `src/App.jsx`: Main state container.\n\n**3. Robustness Requirements**\n*   **Error Handling**: If the API returns 404 (City not found), display a user-friendly error message in the UI, not just the console.\n*   **Loading States**: Show a skeleton loader or spinner while data is fetching.\n*   **Environment**: Access API key via `import.meta.env.VITE_WEATHER_API_KEY`. Create a `.env.example` file.\n\n**4. Verification**\n*   Run `npm run lint` to ensure code quality.",
    "author": "Santhosh Sachin",
    "createdAt": "2025-12-09T10:00:00Z"
  },
  {
    "id": "5",
    "title": "Kanban Board",
    "description": "Complex drag-and-drop interactions using dnd-kit. Focuses on logic and state immutability.",
    "tags": [
      "Medium",
      "React",
      "dnd-kit",
      "TypeScript"
    ],
    "prompt": "**System Role**: You are a UI/UX Engineer Agent.\n**Objective**: Build a Trello-style Kanban Board with drag-and-drop capabilities.\n\n**Tech Stack**: React, TypeScript, Tailwind CSS, @dnd-kit/core.\n\n**Step-by-Step Plan**:\n\n1.  **Scaffold**: Create `kanban-board` (Vite + TS).\n2.  **Dependencies**: `npm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities clsx tailwind-merge`.\n3.  **Data Model (TypeScript)**:\n    *   Define interfaces in `src/types.ts`:\n        ```typescript\n        export type Id = string | number;\n        export type Task = { id: Id; columnId: Id; content: string; };\n        export type Column = { id: Id; title: string; };\n        ```\n4.  **Core Logic (`useKanban.ts`)**:\n    *   Implement a custom hook to manage state.\n    *   **Critical**: Handle `onDragOver` (moving between columns) and `onDragEnd` (dropping).\n    *   Use `arrayMove` from dnd-kit for reordering.\n5.  **UI Implementation**:\n    *   Create `KanbanBoard.tsx`, `ColumnContainer.tsx`, `TaskCard.tsx`.\n    *   Ensure the UI is fluid and responsive.\n\n**Verification**:\n*   Ensure no TypeScript \"any\" types are used.\n*   Verify that dragging a task to an empty column works (common edge case).",
    "author": "Santhosh Sachin",
    "createdAt": "2025-12-09T10:00:00Z"
  },
  {
    "id": "6",
    "title": "Expense Tracker",
    "description": "Financial dashboard with data visualization. Focuses on Context API and Chart.js integration.",
    "tags": [
      "Medium",
      "React",
      "Chart.js",
      "Context API"
    ],
    "prompt": "**System Role**: You are a Full-Stack JavaScript Agent.\n**Objective**: Build a Personal Finance Visualizer.\n\n**Workflow**:\n\n1.  **Setup**: React + Vite + Tailwind.\n2.  **State Management (Context API)**:\n    *   Create `src/context/GlobalState.jsx`.\n    *   Use `useReducer` for actions: `ADD_TRANSACTION`, `DELETE_TRANSACTION`.\n    *   Persist state to `localStorage` within the provider.\n3.  **Visualization**:\n    *   Install `chart.js` and `react-chartjs-2`.\n    *   Create `src/components/ExpenseChart.jsx`.\n    *   **Logic**: Aggregate transactions by category (e.g., \"Food\", \"Rent\") before passing to the Doughnut chart.\n4.  **Components**:\n    *   `Balance.jsx`: Calculate total.\n    *   `IncomeExpenses.jsx`: Show income (green) vs expense (red).\n    *   `TransactionList.jsx`: Render history with delete button.\n\n**Tool Usage**:\n*   Use `write_to_file` to create each component in isolation.\n*   Ensure `App.jsx` wraps everything in `<GlobalProvider>`.",
    "author": "Santhosh Sachin",
    "createdAt": "2025-12-09T10:00:00Z"
  },
  {
    "id": "7",
    "title": "Real-time Chat App",
    "description": "A full-stack Node.js + React application using Socket.io. Requires managing two concurrent processes.",
    "tags": [
      "Pro",
      "Node.js",
      "Socket.io",
      "Full-Stack"
    ],
    "prompt": "**System Role**: You are a Full-Stack Systems Agent.\n**Objective**: Build a Real-time Chat Application (Client + Server).\n\n**Architecture**:\n*   **Root**: `chat-app/`\n    *   **Server**: `chat-app/server` (Node/Express/Socket.io)\n    *   **Client**: `chat-app/client` (React/Vite)\n\n**Detailed Execution Plan**:\n\n**Phase 1: Server Side**\n1.  Use `run_command` to setup `server`.\n2.  Create `server/index.js`:\n    *   Setup Express and http server.\n    *   Initialize Socket.io with CORS allowing `http://localhost:5173`.\n    *   **Events**: Handle `join_room`, `send_message`, `disconnect`.\n    *   **Memory Store**: Keep track of active users in a simple object.\n\n**Phase 2: Client Side**\n1.  Use `run_command` to setup `client`.\n2.  Install `socket.io-client`.\n3.  **UI**: Build a clean interface with a \"Join Room\" screen and a \"Chat\" screen.\n4.  **Hooks**: Use `useEffect` to listen for incoming messages and update the message list state.\n\n**Phase 3: Orchestration**\n1.  Create a root `package.json` with a script `\"dev\": \"concurrently \\\"npm run server\\\" \\\"npm run client\\\"\"`.\n2.  **Verification**: Ensure that opening two browser tabs allows real-time communication.",
    "author": "Santhosh Sachin",
    "createdAt": "2025-12-09T10:00:00Z"
  },
  {
    "id": "8",
    "title": "E-commerce Storefront",
    "description": "Next.js App Router project with Zustand state management. Focuses on modern Next.js patterns.",
    "tags": [
      "Pro",
      "Next.js",
      "Zustand",
      "TypeScript"
    ],
    "prompt": "**System Role**: You are a Next.js Expert Agent.\n**Objective**: Build a Mock E-commerce Store using Next.js 14+ App Router.\n\n**Constraints & Tools**:\n*   **Framework**: Next.js (App Router).\n*   **State**: Zustand (for Cart).\n*   **Styling**: Tailwind CSS.\n\n**Workflow**:\n\n1.  **Scaffold**:\n    *   `npx create-next-app@latest ecommerce --typescript --tailwind --eslint --no-src-dir`.\n2.  **State Management (`store/cart.ts`)**:\n    *   Create a Zustand store with `persist` middleware (save cart to localStorage).\n    *   Actions: `addItem`, `removeItem`, `updateQty`, `clearCart`.\n3.  **UI Components**:\n    *   `components/ProductCard.tsx`: Use `next/image` for optimization.\n    *   `components/CartSidebar.tsx`: A slide-over drawer using Headless UI or custom CSS.\n4.  **Routing**:\n    *   `app/page.tsx`: Product Grid (Mock data).\n    *   `app/product/[id]/page.tsx`: Dynamic product details.\n    *   `app/checkout/page.tsx`: Simple form.\n\n**Verification**:\n*   Use `run_command` to run `npm run build`.\n*   Ensure all images have `alt` tags (accessibility check).",
    "author": "Santhosh Sachin",
    "createdAt": "2025-12-09T10:00:00Z"
  },
  {
    "id": "9",
    "title": "Blog Platform with Auth",
    "description": "Full-stack Next.js app with Database and Authentication. Requires handling sensitive config.",
    "tags": [
      "Pro",
      "Next.js",
      "Prisma",
      "NextAuth"
    ],
    "prompt": "**System Role**: You are a Backend-Focused Agent.\n**Objective**: Build a Blog Platform with Authentication and Database.\n\n**Stack**: Next.js, Prisma (SQLite for dev), NextAuth.js v5.\n\n**Step-by-Step Implementation**:\n\n1.  **Setup**:\n    *   Init Next.js project.\n    *   Install `prisma`, `@prisma/client`, `next-auth`, `@auth/prisma-adapter`.\n2.  **Database Layer**:\n    *   Run `npx prisma init`.\n    *   **Schema**: Define `User`, `Account`, `Session`, `Post` in `prisma/schema.prisma`.\n    *   **Migration**: Run `npx prisma db push`.\n3.  **Authentication**:\n    *   Configure NextAuth in `app/api/auth/[...nextauth]/route.ts`.\n    *   Use `GitHubProvider`.\n4.  **API Routes**:\n    *   `POST /api/posts`: Protected route (check session). Create post.\n    *   `GET /api/posts`: Public route. Fetch all published posts.\n5.  **Frontend**:\n    *   Use `useSession` hook to show \"Login\" or \"Create Post\" buttons.\n\n**Security**:\n*   Create a `.env.local` file template.\n*   Do NOT hardcode secrets. Use environment variables.",
    "author": "Santhosh Sachin",
    "createdAt": "2025-12-09T10:00:00Z"
  },
  {
    "id": "10",
    "title": "SaaS Boilerplate (Unicorn)",
    "description": "The ultimate starter kit. Integrates Stripe, Supabase, and Auth. Explicitly uses MCPs for DB management.",
    "tags": [
      "Expert",
      "SaaS",
      "Stripe",
      "Supabase",
      "MCP"
    ],
    "prompt": "**System Role**: You are a Principal Software Architect Agent.\n**Objective**: Scaffold a Production-Ready SaaS Boilerplate.\n\n**Context**: This is a high-complexity task. You must use available MCPs to ensure database correctness.\n\n**Tech Stack**:\n*   **Frontend**: Next.js 14 (App Router), Shadcn/UI.\n*   **Backend**: Supabase (PostgreSQL), Drizzle ORM.\n*   **Auth**: Clerk or Supabase Auth.\n*   **Payments**: Stripe.\n\n**Agentic Workflow**:\n\n**Phase 1: Foundation**\n1.  **Scaffold**: Initialize Next.js.\n2.  **UI Library**: Run `npx shadcn-ui@latest init` to set up the design system. Add `button`, `input`, `card`, `dialog`.\n\n**Phase 2: Database (MCP Integration)**\n1.  **Schema Design**: Create `db/schema.ts`. Define `profiles`, `subscriptions`, `invoices`.\n2.  **MCP Action**:\n    *   Check if a **PostgreSQL MCP** is available.\n    *   If yes, use it to connect to the DB and execute the migration SQL directly.\n    *   If no, generate the migration file via `drizzle-kit` and instruct the user to run it.\n\n**Phase 3: Stripe Integration**\n1.  **Webhooks**: Create `app/api/webhooks/stripe/route.ts`.\n2.  **Logic**: Handle `checkout.session.completed` to provision the subscription in the DB.\n3.  **Security**: Verify the Stripe signature.\n\n**Phase 4: Dashboard**\n1.  Create a protected layout `app/dashboard/layout.tsx`.\n2.  Implement a \"SubscriptionStatus\" component that gates content based on the DB state.\n\n**Verification**:\n*   Run a full type check: `tsc --noEmit`.\n*   Ensure all environment variables are documented in `.env.example`.",
    "author": "Santhosh Sachin",
    "createdAt": "2025-12-09T10:00:00Z"
  },
  {
    "id": "11",
    "title": "RAG AI Pipeline",
    "description": "Builds a Retrieval Augmented Generation system. Manages Python environments and Vector DBs.",
    "tags": [
      "Expert",
      "AI",
      "Python",
      "RAG",
      "FastAPI"
    ],
    "prompt": "**System Role**: You are an AI Engineering Agent.\n**Objective**: Build a RAG (Retrieval Augmented Generation) Pipeline.\n\n**Architecture**:\n*   **Backend**: Python (FastAPI).\n*   **Vector DB**: ChromaDB (Local).\n*   **LLM**: OpenAI API or Gemini API.\n*   **Frontend**: Next.js.\n\n**Detailed Plan**:\n\n**1. Python Environment (Backend)**\n*   Use `run_command` to:\n    *   Create `backend/`.\n    *   Run `python3 -m venv venv`.\n    *   Activate venv and install: `fastapi uvicorn chromadb langchain pypdf openai`.\n*   **Code**: Create `backend/main.py`.\n    *   Endpoint `/ingest`: Accepts PDF. Uses `PyPDFLoader`. Splits text. Embeds using `OpenAIEmbeddings`. Stores in Chroma.\n    *   Endpoint `/chat`: Accepts query. Searches Chroma. Sends context + query to LLM. Returns answer.\n\n**2. Frontend (Next.js)**\n*   Scaffold `frontend/`.\n*   **UI**: A chat interface with a file upload drag-and-drop zone.\n*   **Integration**: Proxy requests to `http://localhost:8000`.\n\n**3. Robustness**:\n*   Implement a \"Processing\" queue for large PDF uploads.\n*   Handle rate limits from the LLM provider.\n\n**Tool Usage**:\n*   Use `write_to_file` for all code generation.\n*   **Crucial**: Do not expose API keys. Use `python-dotenv`.",
    "author": "Santhosh Sachin",
    "createdAt": "2025-12-09T10:00:00Z"
  },
  {
    "id": "12",
    "title": "Collaborative Whiteboard",
    "description": "Real-time multiplayer canvas using CRDTs. The most complex frontend challenge.",
    "tags": [
      "Expert",
      "WebSockets",
      "CRDT",
      "Canvas",
      "Liveblocks"
    ],
    "prompt": "**System Role**: You are a Real-Time Systems Architect.\n**Objective**: Build a Multiplayer Infinite Canvas (Figma Lite).\n\n**Tech Stack**: Next.js, Liveblocks (for CRDTs), React-Konva (for Canvas).\n\n**Agentic Workflow**:\n\n**Phase 1: Setup**\n1.  Install dependencies: `@liveblocks/client @liveblocks/react konva react-konva`.\n2.  **Config**: Create `liveblocks.config.ts`.\n    *   Define `Storage`: `layers: LiveMap<string, Layer>`, `layerIds: LiveList<string>`.\n    *   Define `Presence`: `cursor: { x: number, y: number } | null`.\n\n**Phase 2: Canvas Logic**\n1.  **Component**: `Canvas.tsx`.\n2.  **Interactions**:\n    *   `onPointerMove`: Update presence (broadcast cursor).\n    *   `onPointerDown`: Start creating a shape (Rectangle/Ellipse).\n    *   `onPointerUp`: Commit shape to the CRDT storage.\n3.  **Rendering**:\n    *   Use `useStorage` to subscribe to changes.\n    *   Render `<Layer>` components based on the `layers` map.\n    *   Render `<Cursor>` components for other users.\n\n**Phase 3: Optimization**\n1.  **Performance**: Ensure the canvas does not re-render unnecessarily. Use `React.memo`.\n2.  **Undo/Redo**: Hook up Liveblocks `room.history.undo()`.\n\n**Verification**:\n*   The app must handle multiple users connecting simultaneously without state divergence.",
    "author": "Santhosh Sachin",
    "createdAt": "2025-12-09T10:00:00Z"
  }
]